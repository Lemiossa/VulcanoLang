./environment.c
/**
 * environment.c
 * Criado por Matheus Leme Da Silva
 * Licença MIT
 */
#include "environment.h"

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include "../util.h"

// Cria um novo Environment
Environment *environmentCreate(size_t initial, Environment *parent) {
	Environment *environment = (Environment *)malloc(sizeof(Environment));
	if (!environment)
		return NULL;

	environment->capacity = initial ? initial : 1;
	environment->count = 0;
	environment->parent = parent;

	environment->objects =
	    (Object *)malloc(environment->capacity * sizeof(Object));
	if (!environment->objects) {
		free(environment);
		return NULL;
	}

	return environment;
}

// Cria um novo objeto num environment
bool environmentPushObject(Environment *environment, Object object) {
	if (!environment) {
		return false;
	}

	if (environment->count >= environment->capacity) {
		size_t newCapacity = environment->capacity * 2;
		Object *newObjects = (Object *)realloc(environment->objects,
		                                       newCapacity * sizeof(Object));
		if (!newObjects) {
			return false;
		}
		environment->capacity = newCapacity;
		environment->objects = newObjects;
	}

	environment->objects[environment->count++] = object;
	return true;
}

// Procura um objeto num environment
// Retorna o ponteiro direto para o Value do objeto
Value *environmentFindObject(Environment *environment, char *start,
                             size_t length) {
	if (!environment || !start || length == 0)
		return NULL;

	Environment *e = environment;
	while (e) {
		for (int i = (int)e->count - 1; i >= 0; i++) {
			Object *object = &e->objects[i];
            if (!object) continue;
			if (object->length == length &&
                    strncmp(start, object->start, length) == 0) {	
                return &object->value;
			}
		}
		e = e->parent;
	}

	return NULL;
}

// Destroi um environment
void environmentDestroy(Environment *environment) {
	if (!environment)
		return;

	environment->capacity = 0;
	environment->count = 0;
	free(environment->objects);
	free(environment);
}
./eval.c
/**
 * eval.c
 * Criado por Matheus Leme Da Silva
 * Licença MIT
 */
#include "eval.h"

#include <math.h>
#include <stdbool.h>
#include <stddef.h>
#include <string.h>

#include "../lexer/token.h"
#include "../parser/ast.h"
#include "arena.h"

// Imprime um "value"
void printValue(Value value) {
	switch (value.type) {
	case VALUE_INTEGER:
		logger(LOG_INFO, "%lld\n", value.value.integer);
		break;
	case VALUE_FLOATING:
		logger(LOG_INFO, "%.16lf\n", value.value.floating);
		break;
	case VALUE_STRING:
		logger(LOG_INFO, "%.*s\n", (int)value.value.string.length,
		       value.value.string.start);
		break;
	case VALUE_BOOLEAN:
		logger(LOG_INFO, "%s\n", value.value.boolean ? "true" : "false");
		break;
	case VALUE_NULL:
		logger(LOG_INFO, "null\n");
		break;
	case VALUE_RETURN_SIGNAL:
		logger(LOG_INFO, "<return signal>\n");
		break;
	case VALUE_ERROR_SIGNAL:
		logger(LOG_INFO, "<error signal>\n");
		break;
	default:
		logger(LOG_INFO, "<unknown value>\n");
		break;
	}
}

// Retorna um Value integer
static Value integer(long long value) {
	Value v;
	v.type = VALUE_INTEGER;
	v.value.integer = value;
	return v;
}

// Retorna um Value float(double)
static Value floating(double value) {
	Value v;
	v.type = VALUE_FLOATING;
	v.value.floating = value;
	return v;
}

// Retorna um Value string
static Value string(const char *start, size_t len) {
	Value v;
	v.type = VALUE_STRING;
	v.value.string.start = start;
	v.value.string.length = len;
	return v;
}

// Retorna um Value boolean
static Value boolean(bool value) {
	Value v;
	v.type = VALUE_BOOLEAN;
	v.value.boolean = value;
	return v;
}

// Retorna um Value null
static Value null(void) {
	Value v;
	v.type = VALUE_NULL;
	return v;
}

// Retorna um Value return signal
static Value returnSignal(Value value, Arena *arena) {
	Value *ret = arenaAlloc(arena, sizeof(Value));
	*ret = value;

	Value v;
	v.type = VALUE_RETURN_SIGNAL;
	v.value.returnValue = ret;
	return v;
}

// Retorna um Value error signal
static Value errorSignal(void) {
	Value v;
	v.type = VALUE_ERROR_SIGNAL;
	return v;
}

// Retorna o Value de retorno de um returnSignal
static Value returnSignalToValue(Value v) {
	if (v.type == VALUE_RETURN_SIGNAL) {
		return *v.value.returnValue;
	}
	return v;
}

// Retorna true se um Value for verdadeiro
static bool isTrue(Value value) {
	switch (value.type) {
	case VALUE_INTEGER: {
		return value.value.integer != 0;
	} break;
	case VALUE_FLOATING: {
		return value.value.floating != 0.0f;
	} break;
	case VALUE_STRING: {
		return value.value.string.length > 0;
	} break;
	case VALUE_BOOLEAN: {
		return value.value.boolean;
	} break;
	case VALUE_NULL: {
		return false;
	} break;
	case VALUE_RETURN_SIGNAL:
	case VALUE_ERROR_SIGNAL: {
		logger(LOG_ERROR, "Internal error: control signal passed to %s()\n",
		       __func__);
		return false;
	} break;
	default: {
		return false;
	} break;
	}
}

// --------------------------------------

Value evalProgram(AstNode *root, Arena *arena, Environment *environment);
Value evalBlockStatement(AstNode *root, Arena *arena, Environment *environment);
Value evalExpressionStatement(AstNode *root, Arena *arena,
                              Environment *environment);
Value evalReturnStatement(AstNode *root, Arena *arena,
                          Environment *environment);
Value evalIfStatement(AstNode *root, Arena *arena, Environment *environment);
Value evalVarStatement(AstNode *root, Arena *arena, Environment *environment);
Value evalNumber(AstNode *root, Arena *arena, Environment *environment);
Value evalString(AstNode *root, Arena *arena, Environment *environment);
Value evalBoolean(AstNode *root, Arena *arena, Environment *environment);
Value evalIdentifier(AstNode *root, Arena *arena, Environment *environment);
Value evalBinaryOp(AstNode *root, Arena *arena, Environment *environment);
Value evalUnaryOp(AstNode *root, Arena *arena, Environment *environment);

// Executa uma ast
Value eval(AstNode *root, Arena *arena, Environment *environment) {
	Value v = null();

	if (!root) {
		logger(LOG_ERROR,
		       "Internal error: Failed to execute code: no have ast\n");
		v.type = VALUE_INTEGER;
		v.value.integer = -1;
		return v;
	}

	if (!arena) {
		logger(LOG_ERROR,
		       "Internal error: Failed to execute code: no have arena\n");
		v.type = VALUE_INTEGER;
		v.value.integer = -1;
		return v;
	}

	if (!environment) {
		logger(LOG_ERROR,
		       "Internal error: Failed to execute code: no have environment\n");
		v.type = VALUE_INTEGER;
		v.value.integer = -1;
		return v;
	}

	switch (root->type) {
	case NODE_PROGRAM: {
		v = evalProgram(root, arena, environment);
	} break;
	case NODE_BLOCK_STATEMENT: {
		v = evalBlockStatement(root, arena, environment);
	} break;
	case NODE_EXPRESSION_STATEMENT: {
		v = evalExpressionStatement(root, arena, environment);
	} break;
	case NODE_RETURN_STATEMENT: {
		v = evalReturnStatement(root, arena, environment);
	} break;
	case NODE_IF_STATEMENT: {
		v = evalIfStatement(root, arena, environment);
	} break;
	case NODE_VAR_STATEMENT: {
		v = evalVarStatement(root, arena, environment);
	} break;
	case NODE_NUMBER: {
		v = evalNumber(root, arena, environment);
	} break;
	case NODE_STRING: {
		v = evalString(root, arena, environment);
	} break;
	case NODE_BOOLEAN: {
		v = evalBoolean(root, arena, environment);
	} break;
	case NODE_NULL:
		break; // Ja inicia em NULL;
	case NODE_IDENTIFIER: {
		v = evalIdentifier(root, arena, environment);
	} break;
	case NODE_ASSIGNMENT:
		break;
	case NODE_BINARYOP: {
		v = evalBinaryOp(root, arena, environment);
	} break;
	case NODE_UNARYOP: {
		v = evalUnaryOp(root, arena, environment);
	} break;
	}

	return v;
}

// Program
Value evalProgram(AstNode *root, Arena *arena, Environment *environment) {
	Value v = null();
	for (size_t i = 0; i < root->data.program.count; i++) {
		v = eval(root->data.program.statements[i], arena, environment);
	}
	return returnSignalToValue(v); // Para caso o usuario use return direto
}

// Block
Value evalBlockStatement(AstNode *root, Arena *arena,
                         Environment *environment) {
	for (size_t i = 0; i < root->data.blockStatement.count; i++) {
		Value tmp =
		    eval(root->data.blockStatement.statements[i], arena, environment);
		if (tmp.type == VALUE_RETURN_SIGNAL) {
			return tmp;
		}
	}
	return null();
}

// Expression
Value evalExpressionStatement(AstNode *root, Arena *arena,
                              Environment *environment) {
	return eval(root->data.expressionStatement.expression, arena, environment);
}

// Return
Value evalReturnStatement(AstNode *root, Arena *arena,
                          Environment *environment) {
	return returnSignal(
	    eval(root->data.returnStatement.expression, arena, environment), arena);
}

// If
Value evalIfStatement(AstNode *root, Arena *arena, Environment *environment) {
	Value condition =
	    eval(root->data.ifStatement.condition, arena, environment);

	Value ret;
	if (isTrue(condition)) {
		ret = eval(root->data.ifStatement.thenBranch, arena, environment);
	} else {
		ret = eval(root->data.ifStatement.elseBranch, arena, environment);
	}

	return returnSignalToValue(ret);
}

// Var
Value evalVarStatement(AstNode *root, Arena *arena, Environment *environment) {
    Object variable;
    variable.start = (char *)root->data.varStatement.identifier->data.identifier.name;
    variable.length = root->data.varStatement.identifier->data.identifier.length;
    variable.value = eval(root->data.varStatement.expression, arena, environment);

    if (variable.value.type == VALUE_ERROR_SIGNAL) return errorSignal();

    if (!environmentPushObject(environment, variable)) {
        logger(LOG_ERROR, "Internal error: Failed to push variable\n");
        return errorSignal();
    }

    return null();
}

// Number
Value evalNumber(AstNode *root, Arena *arena, Environment *environment) {
	(void)arena;
	(void)environment;
	Value v = null();
	if (root->data.number.isFloat) {
		v = floating(root->data.number.value.floating);
	} else {
		v = integer(root->data.number.value.integer);
	}
	return v;
}

// String
Value evalString(AstNode *root, Arena *arena, Environment *environment) {
	(void)arena;
	(void)environment;
	return string(root->data.string.start, root->data.string.length);
}

// Boolean
Value evalBoolean(AstNode *root, Arena *arena, Environment *environment) {
	(void)arena;
	(void)environment;
	return boolean(root->data.boolean.value);
}

// Identifier
Value evalIdentifier(AstNode *root, Arena *arena, Environment *environment) {
	(void)arena;
    Value *value =
	    environmentFindObject(environment, (char *)root->data.identifier.name,
	                          root->data.identifier.length);
	if (!value) {
		tokenLogger(LOG_ERROR, *root->token,
		            "Runtime error: Undefined reference: %.*s\n",
		            root->data.identifier.length, root->data.identifier.name);
		return errorSignal();
	}

	return *value;
}

// BinaryOp
Value evalBinaryOp(AstNode *root, Arena *arena, Environment *environment) {
	Value v;

	Value left = eval(root->data.binaryOp.left, arena, environment);
	Value right = eval(root->data.binaryOp.right, arena, environment);
	if (root->data.binaryOp.operator == TOKEN_OR) {
		v = boolean(isTrue(left) || isTrue(right));
	} else if (root->data.binaryOp.operator == TOKEN_AND) {
		v = boolean(isTrue(left) && isTrue(right));
	} else if (root->data.binaryOp.operator == TOKEN_BIT_OR) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer | right.value.integer);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Bitwise or with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_BIT_XOR) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer ^ right.value.integer);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Bitwise xor with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_BIT_AND) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer & right.value.integer);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Bitwise and with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_EQ) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = boolean(left.value.integer == right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = boolean(left.value.floating == right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = boolean(left.value.floating == (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = boolean((double)left.value.integer == right.value.floating);
		} else if (left.type == VALUE_STRING && right.type == VALUE_STRING) {
			if (left.value.string.length != right.value.string.length) {
				v = boolean(false);
			} else {
				v = boolean(strncmp(left.value.string.start,
				                    right.value.string.start,
				                    left.value.string.length) == 0);
			}
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Comparison with incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_NEQ) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = boolean(left.value.integer != right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = boolean(left.value.floating != right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = boolean(left.value.floating != (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = boolean((double)left.value.integer != right.value.floating);
		} else if (left.type == VALUE_STRING && right.type == VALUE_STRING) {
			if (left.value.string.length != right.value.string.length) {
				v = boolean(true);
			} else {
				v = boolean(strncmp(left.value.string.start,
				                    right.value.string.start,
				                    left.value.string.length) != 0);
			}
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Comparison with incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_LT) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = boolean(left.value.integer < right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = boolean(left.value.floating < right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = boolean(left.value.floating < (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = boolean((double)left.value.integer < right.value.floating);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Comparison with incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_GT) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = boolean(left.value.integer > right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = boolean(left.value.floating > right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = boolean(left.value.floating > (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = boolean((double)left.value.integer > right.value.floating);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Comparison with incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_LTE) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = boolean(left.value.integer <= right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = boolean(left.value.floating <= right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = boolean(left.value.floating <= (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = boolean((double)left.value.integer <= right.value.floating);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Comparison with incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_GTE) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = boolean(left.value.integer >= right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = boolean(left.value.floating >= right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = boolean(left.value.floating >= (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = boolean((double)left.value.integer >= right.value.floating);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Comparison with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_SHIFT_LEFT) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer << right.value.integer);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Shift with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_SHIFT_RIGHT) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer >> right.value.integer);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Shift with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_PLUS) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer + right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = floating(left.value.floating + right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = floating(left.value.floating + (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = floating((double)left.value.integer + right.value.floating);
		} else if (left.type == VALUE_STRING && right.type == VALUE_STRING) {
			size_t newLength =
			    left.value.string.length + right.value.string.length;
			char *start = (char *)arenaAlloc(arena, newLength);
			memcpy(start, left.value.string.start, left.value.string.length);
			memcpy(start + left.value.string.length, right.value.string.start,
			       right.value.string.length);
			v = string(start, newLength);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Sum with incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_MINUS) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer - right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = floating(left.value.floating - right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = floating(left.value.floating - (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = floating((double)left.value.integer - right.value.floating);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Subtraction with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_STAR) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			v = integer(left.value.integer * right.value.integer);
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			v = floating(left.value.floating * right.value.floating);
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			v = floating(left.value.floating * (double)right.value.integer);
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			v = floating((double)left.value.integer * right.value.floating);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Multiplication with "
			            "incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_SLASH) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			if (right.value.integer == 0) {
				if (root->token)
					tokenLogger(LOG_ERROR, *root->token,
					            "Runtime error: Division by zero");
				return errorSignal();
			} else {
				return integer(left.value.integer / right.value.integer);
			}
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			if (right.value.floating == 0.0f) {
				tokenLogger(LOG_ERROR, *root->token,
				            "Runtime error: Division by zero");
				return errorSignal();
			} else {
				return floating(left.value.floating / right.value.floating);
			}
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			if (right.value.integer == 0) {
				tokenLogger(LOG_ERROR, *root->token,
				            "Runtime error: Division by zero");
				return errorSignal();
			} else {
				return floating(left.value.floating /
				                (double)right.value.integer);
			}
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			if (right.value.floating == 0.0f) {
				tokenLogger(LOG_ERROR, *root->token,
				            "Runtime error: Division by zero");
				return errorSignal();
			} else {
				return floating((double)left.value.integer /
				                right.value.floating);
			}
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Division with incompatible types");
			return errorSignal();
		}
	} else if (root->data.binaryOp.operator == TOKEN_PERCENT) {
		if (left.type == VALUE_INTEGER && right.type == VALUE_INTEGER) {
			if (right.value.integer == 0) {
				tokenLogger(LOG_ERROR, *root->token,
				            "Runtime error: Module by zero");
				return errorSignal();
			} else {
				return integer(left.value.integer % right.value.integer);
			}
		} else if (left.type == VALUE_FLOATING &&
		           right.type == VALUE_FLOATING) {
			if (right.value.floating == 0.0f) {
				tokenLogger(LOG_ERROR, *root->token,
				            "Runtime error: Module by zero");
				return errorSignal();
			} else {
				return floating(
				    fmod(left.value.floating, right.value.floating));
			}
		} else if (left.type == VALUE_FLOATING && right.type == VALUE_INTEGER) {
			if (right.value.integer == 0) {
				tokenLogger(LOG_ERROR, *root->token,
				            "Runtime error: Module by zero");

				return errorSignal();
			} else {
				return floating(
				    fmod(left.value.floating, (double)right.value.integer));
			}
		} else if (left.type == VALUE_INTEGER && right.type == VALUE_FLOATING) {
			if (right.value.floating == 0.0f) {
				tokenLogger(LOG_ERROR, *root->token,
				            "Runtime error: Module by zero");
				return errorSignal();
			} else {
				return floating(
				    fmod((double)left.value.integer, right.value.floating));
			}
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Module with incompatible types");
			return errorSignal();
		}
	}

	return v;
}

// UnaryOp
Value evalUnaryOp(AstNode *root, Arena *arena, Environment *environment) {
	Value v = null();
	Value operand = eval(root->data.unaryOp.operand, arena, environment);
	TokenType operator = root->data.unaryOp.operator;

	if (operator == TOKEN_PLUS) {
		if (operand.type == VALUE_INTEGER) {
			v = integer(operand.value.integer);
		} else if (operand.type == VALUE_FLOATING) {
			v = floating(operand.value.floating);
		} else {
			tokenLogger(
			    LOG_ERROR, *root->token,
			    "Runtime error: Unary plus operator with incompatible type\n");
			return errorSignal();
		}
	} else if (operator == TOKEN_MINUS) {
		if (operand.type == VALUE_INTEGER) {
			v = integer(-operand.value.integer);
		} else if (operand.type == VALUE_FLOATING) {
			v = floating(-operand.value.floating);
		} else {
			tokenLogger(
			    LOG_ERROR, *root->token,
			    "Runtime error: Unary minus operator with incompatible type\n");
			return errorSignal();
		}
	} else if (operator == TOKEN_BIT_NOT) {
		if (operand.type == VALUE_INTEGER) {
			v = integer(~operand.value.integer);
		} else {
			tokenLogger(LOG_ERROR, *root->token,
			            "Runtime error: Unary bitwise not operator with "
			            "incompatible type\n");
			return errorSignal();
		}
	}

	return v;
}
./arena.c
/**
 * arena.c
 * Criado por Matheus Leme Da Silva
 * Licença MIT
 */
#include "arena.h"

#include <stdlib.h>

// Cria uma arena
Arena *arenaCreate(size_t initial) {
	Arena *a = (Arena *)malloc(sizeof(Arena));
	if (!a)
		return NULL;

	// Inicializar
	a->buffer = malloc(initial);
	a->length = initial;
	a->offset = 0;
	if (!a->buffer) {
		free(a);
		return NULL;
	}

	return a;
}

// Aloca na arena
void *arenaAlloc(Arena *arena, size_t length) {
	if (!arena)
		return NULL;

	if (arena->offset + length > arena->length) {
		// Realocar com o novo tamanho
		size_t newLength = arena->length * 2;

		if (newLength < arena->offset + length)
			newLength = arena->offset + length;

		void *newPtr = realloc(arena->buffer, newLength);
		if (!newPtr)
			return NULL;

		arena->length = newLength;
		arena->buffer = newPtr;
	}

	void *ptr = arena->buffer + arena->offset;
	arena->offset += length;
	return ptr;
}

// Reseta a Arena
void arenaReset(Arena *arena) {
	if (!arena)
		return;
	arena->offset = 0;
}

// Destroí uma Arena
void arenaDestroy(Arena *arena) {
	if (!arena)
		return;
	free(arena->buffer);
	arena->buffer = NULL;
	arena->length = 0;
	arena->offset = 0;
	free(arena);
}
./eval.h
/**
 * eval.h
 * Criado por Matheus Leme Da Silva
 * Licença MIT
 */
#pragma once
#include "../parser/ast.h"
#include "arena.h"
#include "environment.h"
#include "value.h"

Value eval(AstNode *root, Arena *arena, Environment *environment);
void printValue(Value value);
./arena.h
/**
 * arena.h
 * Criado por Matheus Leme Da Silva
 * Licença MIT
 */
#pragma once
#include <stddef.h>

typedef struct Arena {
	void *buffer;
	size_t length;
	size_t offset;
} Arena;

Arena *arenaCreate(size_t initial);
void *arenaAlloc(Arena *arena, size_t length);
void arenaReset(Arena *arena);
void arenaDestroy(Arena *arena);
./value.h
/**
 * value.h
 * Criado por Matheus Leme Da Silva
 * Licença MIT
 */
#pragma once
#include <stdbool.h>
#include <stddef.h>

typedef enum {
	VALUE_INTEGER = 1,
	VALUE_FLOATING,
	VALUE_STRING,
	VALUE_BOOLEAN,
	VALUE_NULL,
	VALUE_RETURN_SIGNAL,
	VALUE_ERROR_SIGNAL
} ValueType;

typedef struct Value {
	ValueType type;
	union {
		long long integer;
		double floating;
		struct {
			const char *start;
			size_t length;
		} string;
		bool boolean;
		struct Value *returnValue;
	} value;
} Value;
./environment.h
/**
 * environment.h
 * Criado por Matheus Leme Da Silva
 * Licença MIT
 */
#pragma once
#include "value.h"
#include <stdbool.h>
#include <stddef.h>

typedef struct Object {
	char *start;
	size_t length;
	Value value;
} Object;

typedef struct Environment {
	Object *objects;
	size_t count;
	size_t capacity;
	struct Environment *parent;
} Environment;

Environment *environmentCreate(size_t initial, Environment *parent);
bool environmentPushObject(Environment *environment, Object object);
Value *environmentFindObject(Environment *environment, char *start,
                             size_t length);
void environmentDestroy(Environment *environment);
